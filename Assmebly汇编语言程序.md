### 汇编语言编写程序的工作过程
汇编程序->编译器->机器码->计算机  
一个汇编程序由伪指令（由编译器执行的指令）、汇编指令(有对应机器码，可以被编译为机器指令，最终被CPU执行。)、
程序返回(套路！程序结束后，将CPU的控制权返还给使得它能够运行的程序)  
#### 程序中的三种伪指令
1. 段定义:
   一个汇编程序由多个段组成，这些段被用来存放代码、数据、或当做栈空间来使用。  
   定义程序中的段:每个段都需要有段名:  
   段名 segment --段的开始  
   段名 ends --段的结束
2. end (不是ends)
   汇编程序的结束标记。弱程序结尾处不加end,编译器在编译程序时，无法知道程序在何处结束。
3. assume(假设)
   假设某一段寄存器和程序中某一个用segment..ends定义的段相关联--assume cs:codemsg指CS段寄存器与codesg关联，将定义的codesg当做程序的代码段使用。  
源程序经编译连接后变为机器码。  
#### 汇编程序的结构  
在DosBox中，Debug直接写入指令编写的汇编程序。  
--- 注释
#### 汇编程序由写出程序到执行可执行文件的过程
1. 写出源文件.asm
   随便什么工具，文本编辑器也行，我使用vscode
2. 编译为目标文件.obj
   masm 文件名
   在DOSBox中使用masm工具进行源文件编译。
   会生成如下3种文件
   1. OBJ(目标文件)对于源程序进行编译要得到的最终结果
   2. LST(列表文件)是编译器将源程序编译为目标文件的过程中产生的中间结果
   3. CRF(交叉引用文件)交叉引用文件，同列表文件是编译器将源程序编译为目标文件过程中产生的中间结果
3. 连接为可执行文件.exe
   link 目标文件名
4. 执行可执行文件
   直接输入文件名。
#### 汇编语言[...]和(...)的区别
1. [...]汇编语法规定表示一个内存单元
   mov ax,[0] 段地址在DS中，偏移地址在[0]中。
2. (...)为学习方便做出的约定，表示一个内存单元或寄存器中的内容。
3. 再约定idata表示常量。
### LOOP指令
CPU执行Loop指令时要进行的操作  
   1. (cx) = (cx) - 1;  
   2. 判断cx 寄存器中的值,不为零则转至 loop 指定标号处，为零则向下执行。  
   s: add ax,ax  
   loop s  
cx寄存器中需要提前存放循环次数，因为(cx)影响着loop指令的执行结果  
使用loop编程的方法:  
1. 在cx寄存器中存放要循环的次数
2. 用标号指定循环开始的位置
3. 在标号和loop指令的中间，写上要循环执行的程序段(循环体)
### 段前缀的使用：一个异常现象及其对策
mov al,[0] 这种直接通过偏移地址赋值给寄存器的情况，可能导致编译为 mov al,00  
也就是编译时[0]容易被编译器编译为常数。  
解决办法，[0]前加上段寄存器名称,如ds:[0],这样向编译器明确表示这个是一个访问内存地址的操作。  

### 在代码段中存放数据
可以在代码段前面，使用dw(定义字型数据) db(定义一个字节) dd(定义一个双字)等关键字,表示其后定义的数据类型是什么  
但是这样会造成代码段混乱，执行时，先从定义的数据段开始  
``` assmebly
   assume cs:code
   code segment
    dw 0123,0456,0789,0abc,0def,0fed,0cba,0987
   code ends
   end
```
解决办法:在代码实际开始位置，加上start:标号指示代码段开始的位置

 ``` assmebly
   assume cs:code
   code segment
    dw 0123,0456,0789,0abc,0def,0fed,0cba,0987
    start : .... ;代码开始位置
   code ends
   end start ; end也可以指示程序的开始位置
```

### 在代码段中使用栈
可以在代码段的前面定义一段，数据为0的空间当做数据栈  
``` asm
   assume cs:codesg
codesg segment
    dw 0123h,0456h,0789h,0abch,0fedh,0cbah,0987h
    dw 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
```
如上dw 0,0,0定义了一段值为0的字空间。

### 将数据、代码、栈放入不同段
为了将数据、代码、栈分开，以便更好管理的程序空间，最好为数据，栈、代码设置不同的段。
```
   assume cs:code,ds:data,ss:stack
   data segment
   dw 0123h,0456h,0789h
   data ends
   stack segment
   stack ends
   cod segment
   start:   ;start标号的位置表示Ip初始值的位置。

   ;初始化数据段寄存器，栈段寄存器

   ；入栈
   ；出栈
   ；程序结束
   cod ends
```