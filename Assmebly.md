以下以8086CPU 16位为一个字 为标准，也就是16位CPU为基准
### 寄存器及其数据存储
以通用寄存器AX为例.  
AX 16位寄存器  
AH AX寄存器的高八位  
AL AL寄存器的低八位  
### mov 和 add指令
mov ax,18 将数字18赋值给AX寄存器  
mov ah,78 将数字78送入AH寄存器  
add ax,8 将寄存器AX中的数值+8,放入AX寄存器中  
mov ax,bx 将寄存器bx中的数值赋值给寄存器ax  
add ax,bx 将ax,bx中的值相加，结果存储在ax中  
### 确定内存地址的方法
1Byte(字节)=8bit(位) 1024Byte = 1KB(千字节) 1024KB=1MB(兆字节) 1024MB=1GB(千兆字节) 1024GB=1TB(千千兆字节)  
CPU访问内存单元时要给出内存单元的地址  
所有的内存单元构成的存储空间是一个一维的线性空间。  
每个内存单元在这个空间中都有唯一地址，这个唯一的地址称为物理地址。  
记住，每一个地址对应一个字节。所以才有如下的寻址能力的推导.  

8086有20位地址总线，可传送20位地址，寻址能力为1M.2的20次方  
8086是16位结构的CPU，运算器一次最多可以处理16位的数据，也就是寄存器最大宽度为16位.  
在8086内部处理的、传输、暂存的地址也是16位，寻址能力也只有64KB,也就是2的16次方 。

8086解决受16位CPU影响如何寻址更多的地址,  
用两个16位地址(段地址，偏移地址)合成一个20位地址  

地址加法器合成物理地址的方法  
物理地址=段地址x2的4次方(向左移4位)+偏移地址。合成结果就是实际物理地址20位  
用两个16位地址相加得到一个20位的物理地址  

### 内存的分段表示法。
8086CPU用"(段地址x 2的4次方)+偏移地址 = 物理地址"的方式给出内存单元的物理地址  
内存实际上没有分段，分段只是CPU处理时的方式。对于CPU而言，同一段内存可以有多种不同的分段方式。  
段地址很重要!--CPU当中有专门的寄存器用于存放段地址寄存器。  
4个段寄存器:  
CS-代码段寄存器     DS-数据段寄存器  
SS-栈段寄存器       ES-附加段寄存器  
偏移地址可用多种方法提供--8086丰富的取值方式。
### DEBUG的使用
debug指令:  
r 查看DOS系统中的调试程序
d 查看内存中的内容  
    直接回车查看预设地址内存处的128个字节的内容  
    D段地址:偏移地址-列出内存中指定地址处的内容
    D段地址:偏移地址 结尾偏移地址 -列出内存中指定地址范围内的内容
e 改变内存中的内容  
    e 段地址:偏移地址 数据1 数据2  
    e 段地址:偏移地址 (逐个询问式修改,空格继续，回车结束)
u 将内存中的机器指令反应成汇编指令  
    u 段地址:偏移地址 结束地址
a 将汇编指令的格式在内存中写入机器指令  
    a 段地址:偏移地址
t 执行机器指令 执行CS:IP处的指令。
### CS和IP寄存器
CPU将CS:IP指向的内存单元看做指令  
CS:代码段寄存器、IP:指令指针寄存器  
1. 从CS:IP指向的内存单元中读取指令，读取的指令进入指令缓冲器  
2. IP=IP+所读取指令长度，从而指向下一条指令  
3. 执行指令。转到流程1，重复这个过程。  
### jmp 跳转指令
执行何处的指令，取决于CS:IP这两个寄存器,可以通过改变CS、IP中的值，来控制CPU需要执行的目标指令。  
使用mov 不能直接给CS、IP这两个寄存器赋值。不合适  
可以使用jmp转移指令，可以改变CS、IP的值，也可以同时修改CS、IP
1. jmp 段地址:偏移地址 用指令中给出的段地址修改CS,偏移地址修改IP
2. jmp 某一合法寄存器 (jmp ax) 用寄存器中的值修改IP中的值.
### 内存中字的存储
对于8086CPU而言，16位作为一个字，也就是2个字节  
对于32位的CPU而言，32位作为一个字，也就是4字节  
对于64位的CPU而言，64位作为一个字，也就是8字节  
16位的字在内存中需要两个连续字节存储，存放时，低位字节，放在低地址单元，高位字节,存放在高地址。  
大端:数据的低位字节存放在内存的高位地址，高位字节存放在低位地址,(人的读取顺序，由低位地址读向高位地址。)  
小端:数据的低位字节放在内存的低位地址,高位字节存放在高位地址,(人的读取顺序，由高位地址向低位地址读取。)。小端序比较适合计算机的读取顺序，从低位地址读到高位地址。  
字单元:对于8086CPU而言，由两个地址连续的内存单元组成，存放一个字型数据(16位,8086CPU)

### CPU从内存单元中要读取数据
在CPU中，内存地址由段地址和偏移地址组成(段地址:偏移地址)  
DS是数据的段地址寄存器  
DS和[address]配合  
用DS寄存器存放要访问的数据的段地址  
偏移地址用[...]形式直接给出  
mov bx,1000H  
mov ds,bx  
mov al,[0]  
mov [0],al  
这样1000:0内存地址的数据将会读取到al中。  
下一步可以将al中的数据，写入到1000:0中  
8086CPU的设计缺陷，不支持将数据直接送入段寄存器当中.所以需要先将段地址存放到通用寄存器中，再赋值到DS段寄存器中。  
mov ds,1000H 不支持  8086CPU不支持
mov ds,bx 支持  
8086CPU一次性可以传输一个字的数据(16位，两个字节)  
同理 32位CPU一次性可以传输一个字的数据(32位，4个字)  
64位CPU一次性可以传输一个字的数据(64位，8字节)  
### DS数据段寄存器与数据段
8086CPU中，物理地址=段地址x16+偏移地址  
将一组长度为N(N<=64K)、***地址连续、起始地址为16的倍数***的内存单元当做专门存储数据的内存空间。
#### mov指令操作数据的方式
mov 寄存器,数据 mov ax,8  
mov 寄存器,寄存器 mov ax,bx  
mov 寄存器,内存单元 mov ax,[0]  
mov 内存单元,寄存器 mov [0],ax  
mov 内存单元,段寄存器 mov [0],ds
mov 段寄存器,内存单元 mov ds,[0]
mov 段寄存器,寄存器 mov ds,ax  
mov 寄存器,段寄存器 mov ax,ds  
#### 加法add和减法sub指令
add 寄存器,数据  
add 寄存器,寄存器  
add 寄存器,内存单元  
add 内存单元,寄存器  
两个内存单元无法直接相加，必须经过CPU寄存器进行计算。  
sub 寄存器,数据  
sub 寄存器,寄存器  
sub 寄存器,内存单元  
sub 内存单元,寄存器  
#### 栈及其栈操作的实现。
栈是一种只能在其一段进行插入或删除的操作。  
栈有两个基本操作:入栈和出栈。  
入栈:将一个新的元素放到栈顶  
出栈:从栈顶取出一个元素  
后进先出  
现今的CPU中都有栈的设计。有相关指令支持用栈的方式访问内存空间。  
push ax:将ax中的数据送入栈中.  
pop ax:从栈顶取出数据送入ax.  
这里是操作一个字的数据,(8086CPU的寄存器大小问题。)  
CPU入栈是入到内存中的栈，也就是以一段内存空间为栈。  
push 体现为内存地址变化的话,也就是SP逐渐减小,将数据入栈到内存时，也是低位地址放低位字节数据，高位地址为高位字节数据。  
同时CPU将内存中的高位地址作为栈底,低位地址作为栈的顶部  
pop时，将栈顶逐渐向栈底靠拢，体现为内存地址的话，表现为，SP逐渐增大，  
8086CPU中有两个与栈相关的寄存器:  
栈段寄存器SS -存放栈顶的段地址  
栈顶指针寄存器SP -存放栈顶的偏移地址  
任意时刻,SS:SP指向栈顶元素。  
push ax  
1. push时,SP=SP-2  
2. 将ax中的内容送入SS:SP指向的2个内存单元处,之后,SP=SP-2,SS:SP指向新栈顶  
pop ax  
1. 将SS:SP指向的内存单元处的地址送入ax寄存器中;
2. SP=SP+2,SS:SP指向当前栈顶下面的单元，以当前栈顶为新栈顶。  
#### 栈的超界问题
执行入栈(push)时，栈顶超出空间。  
### 关于段的总结
编程时，可以根据需要将一组内存单元定义为一个段。  
可以将起始地址为16的倍数，长度为N(N<=64KB)的一组连续的内存单元，定义为一个段。  
将一段内存定义为一个段，用一个段地址指示段，用偏移地址访问段内的单元--在程序中可以完全由程序员安排。  
目前学习了三种段:  
1. 数据段  
将短笛值放在DS数据段寄存器中。使用mov,add,sub等访问内存单元的指令时将我们定义的数据段中的内容当做数据段来访问；
2. 代码段  
将段地址放在CS中，将段中第一条指令的偏移地址放在IP中  
3. 栈段
将段地址放在SS中，将栈顶单元的偏移地址放在SP中  
CPU在需要进行栈操作(push、pop)时，就将我们定义的栈段当做栈空间来用。  